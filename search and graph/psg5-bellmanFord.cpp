/* Bellman-Ford算法可以处理负权边，时间复杂度是O(nm)，
 * 外层循环是遍历所有节点，内层循环是遍历所有边，
 * 所以时间复杂度就是节点数乘以边数。
 * 
 * 但是Bellman-Ford算法不能处理负权回路，因为负权回路可以无限次地松弛，
 * 判断负权回路的方法是，如果某次迭代中没有任何边被松弛，那么就说明没有负权回路，
 * 如果迭代到第n+1次，仍然有边被松弛，那么就说明有负权回路。
 * 
 * 此外，Bellman-Ford算法可以用来处理这样一种问题：从某个点出发，最多经过k条边到达目的地。
 * 这种问题可以用Bellman-Ford算法求解，只需要将外层循环改成k次即可，但是这里有一个非常重要的点，
 * 每次迭代后，必须用一个备份数组来保存当前的最短路径数组，下一次迭代时只能用备份数组来更新最短路径数组，然后再备份，以此类推，
 * 这是因为，如果直接在最短路径数组上进行更新，那么在内层遍历所有边时，后面的边可能会直接用到前面的边的结果，从而影响了最多经过k条边的限定。
 * 这就像Jacobbi迭代法和Gauss-Seidel迭代法的区别一样，Jacobbi迭代法是用上一次迭代的结果来更新所有的变量。
 * 
 * 总的来说，如果不要求最多经过k条边，那么可以不用备份数组，否则需要加上备份数组。
*/